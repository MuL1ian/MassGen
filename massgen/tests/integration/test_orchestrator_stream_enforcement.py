# -*- coding: utf-8 -*-
"""Deterministic non-API integration tests for orchestrator stream enforcement."""

from __future__ import annotations

import pytest


def _configure_agent_script(agent, scripted_tool_calls, responses=None):
    """Attach deterministic per-call tool scripts to a mock-backed agent."""
    agent.backend.tool_call_responses = scripted_tool_calls
    agent.backend.responses = responses or ["ok"] * len(scripted_tool_calls)


async def _collect_stream(stream):
    """Collect all tuples emitted by an orchestrator stream."""
    emitted = []
    async for item in stream:
        emitted.append(item)
    return emitted


@pytest.mark.asyncio
async def test_stream_agent_execution_emits_answer_result_for_new_answer(mock_orchestrator):
    orchestrator = mock_orchestrator(num_agents=2)
    orchestrator.current_task = "Draft a release summary."
    orchestrator.config.disable_injection = True

    agent_id = "agent_a"
    _configure_agent_script(
        orchestrator.agents[agent_id],
        scripted_tool_calls=[
            [{"name": "new_answer", "arguments": {"content": "Final answer from A"}}],
        ],
    )

    emitted = await _collect_stream(
        orchestrator._stream_agent_execution(agent_id, orchestrator.current_task, {}),
    )

    assert ("result", ("answer", "Final answer from A")) in emitted
    assert emitted[-1] == ("done", None)


@pytest.mark.asyncio
async def test_stream_agent_execution_emits_vote_result_for_valid_vote(mock_orchestrator):
    orchestrator = mock_orchestrator(num_agents=2)
    orchestrator.current_task = "Pick best option."
    orchestrator.config.disable_injection = True

    agent_id = "agent_a"
    orchestrator.agent_states["agent_b"].answer = "Candidate answer B"
    _configure_agent_script(
        orchestrator.agents[agent_id],
        scripted_tool_calls=[
            [{"name": "vote", "arguments": {"agent_id": "agent_b", "reason": "Most complete"}}],
        ],
    )

    emitted = await _collect_stream(
        orchestrator._stream_agent_execution(
            agent_id,
            orchestrator.current_task,
            {},
        ),
    )

    result_items = [item for item in emitted if item[0] == "result"]
    assert result_items
    assert result_items[0][1][0] == "vote"
    assert result_items[0][1][1]["agent_id"] == "agent_b"
    assert emitted[-1] == ("done", None)


@pytest.mark.asyncio
async def test_stream_agent_execution_retries_invalid_vote_then_accepts_valid_vote(mock_orchestrator):
    orchestrator = mock_orchestrator(num_agents=2)
    orchestrator.current_task = "Vote with retry."
    orchestrator.config.disable_injection = True

    agent_id = "agent_a"
    orchestrator.agent_states["agent_b"].answer = "Answer B"
    _configure_agent_script(
        orchestrator.agents[agent_id],
        scripted_tool_calls=[
            [{"name": "vote", "arguments": {"agent_id": "not_an_agent", "reason": "mistake"}}],
            [{"name": "vote", "arguments": {"agent_id": "agent_b", "reason": "corrected"}}],
        ],
        responses=["first attempt", "second attempt"],
    )

    emitted = await _collect_stream(
        orchestrator._stream_agent_execution(
            agent_id,
            orchestrator.current_task,
            {},
        ),
    )

    retry_messages = [item for item in emitted if item[0] == "content" and "Invalid agent_id" in item[1]]
    vote_results = [item for item in emitted if item[0] == "result" and item[1][0] == "vote"]
    assert retry_messages
    assert vote_results
    assert vote_results[0][1][1]["agent_id"] == "agent_b"


@pytest.mark.asyncio
async def test_stream_agent_execution_retries_vote_without_answers_then_accepts_new_answer(mock_orchestrator):
    orchestrator = mock_orchestrator(num_agents=2)
    orchestrator.current_task = "Fallback to answer."
    orchestrator.config.disable_injection = True

    agent_id = "agent_a"
    _configure_agent_script(
        orchestrator.agents[agent_id],
        scripted_tool_calls=[
            [{"name": "vote", "arguments": {"agent_id": "agent_a", "reason": "premature"}}],
            [{"name": "new_answer", "arguments": {"content": "Standalone answer after retry"}}],
        ],
        responses=["vote attempt", "new answer attempt"],
    )

    emitted = await _collect_stream(
        orchestrator._stream_agent_execution(agent_id, orchestrator.current_task, {}),
    )

    retry_messages = [item for item in emitted if item[0] == "content" and "Cannot vote when no answers exist" in item[1]]
    answer_results = [item for item in emitted if item[0] == "result" and item[1][0] == "answer"]
    assert retry_messages
    assert answer_results
    assert answer_results[0][1][1] == "Standalone answer after retry"


@pytest.mark.asyncio
async def test_stream_agent_execution_rejects_mixed_vote_and_new_answer_then_accepts_answer(mock_orchestrator):
    orchestrator = mock_orchestrator(num_agents=2)
    orchestrator.current_task = "Enforce one workflow action."
    orchestrator.config.disable_injection = True

    agent_id = "agent_a"
    orchestrator.agent_states["agent_b"].answer = "Existing answer"
    _configure_agent_script(
        orchestrator.agents[agent_id],
        scripted_tool_calls=[
            [
                {"name": "vote", "arguments": {"agent_id": "agent_b", "reason": "mixed"}},
                {"name": "new_answer", "arguments": {"content": "mixed attempt"}},
            ],
            [{"name": "new_answer", "arguments": {"content": "clean answer"}}],
        ],
        responses=["mixed attempt", "clean attempt"],
    )

    emitted = await _collect_stream(
        orchestrator._stream_agent_execution(
            agent_id,
            orchestrator.current_task,
            {},
        ),
    )

    retry_messages = [item for item in emitted if item[0] == "content" and "Cannot use both 'vote' and 'new_answer'" in item[1]]
    answer_results = [item for item in emitted if item[0] == "result" and item[1][0] == "answer"]
    assert retry_messages
    assert answer_results
    assert answer_results[0][1][1] == "clean answer"


@pytest.mark.asyncio
async def test_stream_agent_execution_errors_after_three_non_workflow_attempts(mock_orchestrator):
    orchestrator = mock_orchestrator(num_agents=2)
    orchestrator.current_task = "Must call workflow tool."
    orchestrator.config.disable_injection = True

    agent_id = "agent_a"
    _configure_agent_script(
        orchestrator.agents[agent_id],
        scripted_tool_calls=[
            [{"name": "unknown_tool", "arguments": {}}],
            [{"name": "unknown_tool", "arguments": {}}],
            [{"name": "unknown_tool", "arguments": {}}],
        ],
        responses=["attempt1", "attempt2", "attempt3"],
    )

    emitted = await _collect_stream(
        orchestrator._stream_agent_execution(agent_id, orchestrator.current_task, {}),
    )

    errors = [item for item in emitted if item[0] == "error"]
    assert errors
    assert "failed to use workflow tools" in errors[-1][1].lower()
    assert emitted[-1] == ("done", None)
